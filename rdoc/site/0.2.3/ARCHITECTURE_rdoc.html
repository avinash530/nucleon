<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>ARCHITECTURE - nucleon 0.2.3</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body class="file">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./ARCHITECTURE_rdoc.html">ARCHITECTURE</a>
  
    <li class="file"><a href="./README_rdoc.html">README</a>
  
    <li class="file"><a href="./TODO_rdoc.html">TODO</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./Nucleon.html">Nucleon</a>
  
    <li><a href="./Nucleon/Action.html">Nucleon::Action</a>
  
    <li><a href="./Nucleon/Action/Extract.html">Nucleon::Action::Extract</a>
  
    <li><a href="./Nucleon/Action/Project.html">Nucleon::Action::Project</a>
  
    <li><a href="./Nucleon/Action/Project/Add.html">Nucleon::Action::Project::Add</a>
  
    <li><a href="./Nucleon/Action/Project/Create.html">Nucleon::Action::Project::Create</a>
  
    <li><a href="./Nucleon/Action/Project/Remove.html">Nucleon::Action::Project::Remove</a>
  
    <li><a href="./Nucleon/Action/Project/Save.html">Nucleon::Action::Project::Save</a>
  
    <li><a href="./Nucleon/Action/Project/Update.html">Nucleon::Action::Project::Update</a>
  
    <li><a href="./Nucleon/Codes.html">Nucleon::Codes</a>
  
    <li><a href="./Nucleon/Command.html">Nucleon::Command</a>
  
    <li><a href="./Nucleon/Command/Bash.html">Nucleon::Command::Bash</a>
  
    <li><a href="./Nucleon/Config.html">Nucleon::Config</a>
  
    <li><a href="./Nucleon/Config/Collection.html">Nucleon::Config::Collection</a>
  
    <li><a href="./Nucleon/Config/Options.html">Nucleon::Config::Options</a>
  
    <li><a href="./Nucleon/Core.html">Nucleon::Core</a>
  
    <li><a href="./Nucleon/Environment.html">Nucleon::Environment</a>
  
    <li><a href="./Nucleon/Errors.html">Nucleon::Errors</a>
  
    <li><a href="./Nucleon/Errors/BatchError.html">Nucleon::Errors::BatchError</a>
  
    <li><a href="./Nucleon/Errors/NucleonError.html">Nucleon::Errors::NucleonError</a>
  
    <li><a href="./Nucleon/Errors/SSHUnavailable.html">Nucleon::Errors::SSHUnavailable</a>
  
    <li><a href="./Nucleon/Event.html">Nucleon::Event</a>
  
    <li><a href="./Nucleon/Event/Regex.html">Nucleon::Event::Regex</a>
  
    <li><a href="./Nucleon/Extension.html">Nucleon::Extension</a>
  
    <li><a href="./Nucleon/Extension/Project.html">Nucleon::Extension::Project</a>
  
    <li><a href="./Nucleon/Facade.html">Nucleon::Facade</a>
  
    <li><a href="./Nucleon/Gems.html">Nucleon::Gems</a>
  
    <li><a href="./Nucleon/Manager.html">Nucleon::Manager</a>
  
    <li><a href="./Nucleon/Mixin.html">Nucleon::Mixin</a>
  
    <li><a href="./Nucleon/Mixin/Action.html">Nucleon::Mixin::Action</a>
  
    <li><a href="./Nucleon/Mixin/Action/Commit.html">Nucleon::Mixin::Action::Commit</a>
  
    <li><a href="./Nucleon/Mixin/Action/Project.html">Nucleon::Mixin::Action::Project</a>
  
    <li><a href="./Nucleon/Mixin/Action/Push.html">Nucleon::Mixin::Action::Push</a>
  
    <li><a href="./Nucleon/Mixin/Action/Registration.html">Nucleon::Mixin::Action::Registration</a>
  
    <li><a href="./Nucleon/Mixin/Colors.html">Nucleon::Mixin::Colors</a>
  
    <li><a href="./Nucleon/Mixin/ConfigCollection.html">Nucleon::Mixin::ConfigCollection</a>
  
    <li><a href="./Nucleon/Mixin/ConfigOptions.html">Nucleon::Mixin::ConfigOptions</a>
  
    <li><a href="./Nucleon/Mixin/Macro.html">Nucleon::Mixin::Macro</a>
  
    <li><a href="./Nucleon/Mixin/Macro/ObjectInterface.html">Nucleon::Mixin::Macro::ObjectInterface</a>
  
    <li><a href="./Nucleon/Mixin/Macro/PluginInterface.html">Nucleon::Mixin::Macro::PluginInterface</a>
  
    <li><a href="./Nucleon/Mixin/Settings.html">Nucleon::Mixin::Settings</a>
  
    <li><a href="./Nucleon/Mixin/SubConfig.html">Nucleon::Mixin::SubConfig</a>
  
    <li><a href="./Nucleon/Parallel.html">Nucleon::Parallel</a>
  
    <li><a href="./Nucleon/Parallel/ClassMethods.html">Nucleon::Parallel::ClassMethods</a>
  
    <li><a href="./Nucleon/Parallel/InstanceMethods.html">Nucleon::Parallel::InstanceMethods</a>
  
    <li><a href="./Nucleon/Plugin.html">Nucleon::Plugin</a>
  
    <li><a href="./Nucleon/Plugin/Action.html">Nucleon::Plugin::Action</a>
  
    <li><a href="./Nucleon/Plugin/Action/Option.html">Nucleon::Plugin::Action::Option</a>
  
    <li><a href="./Nucleon/Plugin/Base.html">Nucleon::Plugin::Base</a>
  
    <li><a href="./Nucleon/Plugin/Command.html">Nucleon::Plugin::Command</a>
  
    <li><a href="./Nucleon/Plugin/Event.html">Nucleon::Plugin::Event</a>
  
    <li><a href="./Nucleon/Plugin/Extension.html">Nucleon::Plugin::Extension</a>
  
    <li><a href="./Nucleon/Plugin/Project.html">Nucleon::Plugin::Project</a>
  
    <li><a href="./Nucleon/Plugin/Template.html">Nucleon::Plugin::Template</a>
  
    <li><a href="./Nucleon/Plugin/Translator.html">Nucleon::Plugin::Translator</a>
  
    <li><a href="./Nucleon/Project.html">Nucleon::Project</a>
  
    <li><a href="./Nucleon/Project/Git.html">Nucleon::Project::Git</a>
  
    <li><a href="./Nucleon/Project/Github.html">Nucleon::Project::Github</a>
  
    <li><a href="./Nucleon/Template.html">Nucleon::Template</a>
  
    <li><a href="./Nucleon/Template/JSON.html">Nucleon::Template::JSON</a>
  
    <li><a href="./Nucleon/Template/Wrapper.html">Nucleon::Template::Wrapper</a>
  
    <li><a href="./Nucleon/Template/YAML.html">Nucleon::Template::YAML</a>
  
    <li><a href="./Nucleon/Translator.html">Nucleon::Translator</a>
  
    <li><a href="./Nucleon/Translator/JSON.html">Nucleon::Translator::JSON</a>
  
    <li><a href="./Nucleon/Translator/YAML.html">Nucleon::Translator::YAML</a>
  
    <li><a href="./Nucleon/Util.html">Nucleon::Util</a>
  
    <li><a href="./Nucleon/Util/CLI.html">Nucleon::Util::CLI</a>
  
    <li><a href="./Nucleon/Util/CLI/Parser.html">Nucleon::Util::CLI::Parser</a>
  
    <li><a href="./Nucleon/Util/Cache.html">Nucleon::Util::Cache</a>
  
    <li><a href="./Nucleon/Util/Console.html">Nucleon::Util::Console</a>
  
    <li><a href="./Nucleon/Util/Data.html">Nucleon::Util::Data</a>
  
    <li><a href="./Nucleon/Util/Disk.html">Nucleon::Util::Disk</a>
  
    <li><a href="./Nucleon/Util/Git.html">Nucleon::Util::Git</a>
  
    <li><a href="./Nucleon/Util/Liquid.html">Nucleon::Util::Liquid</a>
  
    <li><a href="./Nucleon/Util/Logger.html">Nucleon::Util::Logger</a>
  
    <li><a href="./Nucleon/Util/Package.html">Nucleon::Util::Package</a>
  
    <li><a href="./Nucleon/Util/SSH.html">Nucleon::Util::SSH</a>
  
    <li><a href="./Nucleon/Util/SSH/Keypair.html">Nucleon::Util::SSH::Keypair</a>
  
    <li><a href="./Nucleon/Util/Shell.html">Nucleon::Util::Shell</a>
  
    <li><a href="./Nucleon/Util/Shell/Result.html">Nucleon::Util::Shell::Result</a>
  
    <li><a href="./Hash.html">Hash</a>
  
    <li><a href="./Kernel.html">Kernel</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation" class="description">
  
<h2 id="label-Nucleon+architecture+guide"><a href="Nucleon.html">Nucleon</a> architecture guide</h2>

<p><a href="Nucleon.html">Nucleon</a> is built to provide an easy and minimal,
yet extremely powerful,  framework for building applications that are
highly distributable in nature.</p>

<p>This project should be applicable to any Ruby application that needs to be 
built in a pluggable, concurrent, and configurable fashion.  It is capable
of  being used as pieces in existing programming models and it provides an 
extremely simple core programming model that you can build on.</p>

<p>There are five major architectural goals of the project:</p>

<h3 id="label-Persistent+and+mergeable+objects">Persistent and mergeable objects</h3>

<h4 id="label-Important+concept%3A++Objects+%3D%3D+Property+trees">Important concept:  Objects == Property trees</h4>

<p>At the core of the <a href="Nucleon.html">Nucleon</a> framework is the
configuration.  The configuration  is used for allowing us to store,
lookup, and perform other operations (such  as merge) on our class data by
treating a subset of class properties as a tree  based data structure.</p>

<p>Examples of <a href="Nucleon.html">Nucleon</a> configurations:</p>

<pre class="ruby"><span class="ruby-identifier">first_config</span> = <span class="ruby-constant">Nucleon</span><span class="ruby-operator">::</span><span class="ruby-constant">Config</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">first_config</span>.<span class="ruby-identifier">set</span>([ :<span class="ruby-identifier">my</span> <span class="ruby-operator">:</span><span class="ruby-identifier">nested</span>, :<span class="ruby-identifier">property</span> ], <span class="ruby-string">&#39;hello&#39;</span>)
<span class="ruby-identifier">first_config</span>.<span class="ruby-identifier">set</span>([ :<span class="ruby-identifier">my</span>, :<span class="ruby-identifier">other</span> ], { :<span class="ruby-identifier">ok</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span> })

<span class="ruby-identifier">tree_data</span> = <span class="ruby-identifier">first_config</span>.<span class="ruby-identifier">export</span>
<span class="ruby-comment"># tree_data = { </span>
<span class="ruby-comment">#   :my =&gt; {</span>
<span class="ruby-comment">#     :nested =&gt; { :property =&gt; &#39;hello&#39; },</span>
<span class="ruby-comment">#     :other  =&gt; { :ok =&gt; true }</span>
<span class="ruby-comment">#   }</span>
<span class="ruby-comment"># }</span>

<span class="ruby-identifier">second_config</span> = <span class="ruby-constant">Nucleon</span><span class="ruby-operator">::</span><span class="ruby-constant">Config</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">second_config</span>.<span class="ruby-identifier">set</span>([ :<span class="ruby-identifier">my</span>, :<span class="ruby-identifier">other</span>, :<span class="ruby-identifier">ok</span> ], <span class="ruby-keyword">false</span>)
<span class="ruby-identifier">second_config</span>.<span class="ruby-identifier">set</span>(:<span class="ruby-identifier">property</span>, <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">second_config</span>.<span class="ruby-identifier">set</span>([ :<span class="ruby-identifier">something</span>, :<span class="ruby-keyword">else</span> ], <span class="ruby-keyword">true</span>)

<span class="ruby-identifier">third_config</span> = <span class="ruby-constant">Nucleon</span><span class="ruby-operator">::</span><span class="ruby-constant">Config</span>.<span class="ruby-identifier">new</span>({ :<span class="ruby-identifier">property</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span> })
<span class="ruby-identifier">third_config</span>.<span class="ruby-identifier">import</span>(<span class="ruby-identifier">first_config</span>)
<span class="ruby-identifier">third_config</span>.<span class="ruby-identifier">defaults</span>(<span class="ruby-identifier">second_config</span>)

<span class="ruby-identifier">tree_data</span> = <span class="ruby-identifier">third_config</span>.<span class="ruby-identifier">export</span>
<span class="ruby-comment"># tree_data = { </span>
<span class="ruby-comment">#   :my =&gt; {</span>
<span class="ruby-comment">#     :nested =&gt; { :property =&gt; &#39;hello&#39; },</span>
<span class="ruby-comment">#     :other  =&gt; { :ok =&gt; true }</span>
<span class="ruby-comment">#   },</span>
<span class="ruby-comment">#   :property =&gt; false,</span>
<span class="ruby-comment">#   :something =&gt; { :else =&gt; true }</span>
<span class="ruby-comment"># }</span>
</pre>

<p>As you can see the concept is pretty simple.  In <a
href="Nucleon.html">Nucleon</a> most classes extend the configuration so
they have the above elastic and persistable qualities.  Upon the
configuration primitives are built specialized accessors / modifiers in sub
classes.  This creates a very dynamic and flexible object model upon which
we  can build effective distributed systems.</p>

<h3 id="label-Extremely+pluggable+and+extensible">Extremely pluggable and extensible</h3>

<p>In the future application programming will focus much more on plugins and
extensions to existing systems than crafting a bunch of standalone systems.
This trend has already begun.  But it can be harder to start an application
with a capable plugin and extensibility model unless already building on an
extensible framework (at which point you are most likely creating plugins).</p>

<p>One of the driving goals behind the <a href="Nucleon.html">Nucleon</a>
project is to deliver a cutting  edge plugin and extensibility model that
other applications or frameworks can  build on to provide their parallel
capable pluggable architecture.  In order  to do this effectively we need
to bridge different extensible systems to create an integrated hybrid.</p>

<p><a href="Nucleon.html">Nucleon</a> provides (and will provide) quite a few
means of extension:</p>

<h4 id="label-Plugin+%2F+providers+architecture">Plugin / providers architecture</h4>

<p><a href="Nucleon.html">Nucleon</a> implements a model where we define a
base API interface/implementation as a base plugin, which can be extended
by specialized providers loaded from a myriad of locations (that you can
define).  This allows us to utilize base  capabilities that can be easily
extended by developers with a single Ruby file provider implementation. 
These plugin instances are usually created via a facade that makes
referencing them very easy.  The facade is layered like an onion so it is
very easy to extend as needed.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-identifier">translator</span> = <span class="ruby-constant">Nucleon</span>.<span class="ruby-identifier">translator</span>({ :<span class="ruby-identifier">provider</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">json</span> })
<span class="ruby-identifier">obj_string</span> = <span class="ruby-identifier">translator</span>.<span class="ruby-identifier">generate</span>(<span class="ruby-identifier">properties</span>)
<span class="ruby-identifier">properties</span> = <span class="ruby-identifier">translator</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">obj_string</span>)
</pre>

<p>It should be noted that ALL <a href="Nucleon.html">Nucleon</a> plugins are
at their core, configurations.</p>

<h4 id="label-Method+block+extension">Method block extension</h4>

<p>Sometimes it is nice to have a base implementation handle mundane details
of a task and leave the juicy bits to the child implementation.  Normally,
in most OOP languages, we do this by simply extending parent methods
through  inheritance.  This leaves us with a problem though.  How can we
get the parent to process before, after, or even in between the execution
of the child  implementation?</p>

<p>Ruby makes thie very easy!  To fulfill this goal we often use code blocks 
passed to the parent that the parent then executes on behalf of the child.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ParentClass</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>
    <span class="ruby-ivar">@logger</span> = <span class="ruby-constant">Log4r</span><span class="ruby-operator">::</span><span class="ruby-constant">Logger</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;over-engineered greeting class&#39;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment">#---</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">say_hello</span>(<span class="ruby-identifier">to</span>, &amp;<span class="ruby-identifier">code</span>)
    <span class="ruby-identifier">result</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-ivar">@logger</span>.<span class="ruby-identifier">debug</span>(<span class="ruby-node">&quot;Invoking say_hello with #{to}&quot;</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">code</span>.<span class="ruby-identifier">call</span>(:<span class="ruby-identifier">validate</span>)
      <span class="ruby-ivar">@logger</span>.<span class="ruby-identifier">debug</span>(<span class="ruby-string">&quot;We&#39;re all good&quot;</span>)
      <span class="ruby-identifier">result</span> = <span class="ruby-identifier">code</span>.<span class="ruby-identifier">call</span>(:<span class="ruby-identifier">run</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-ivar">@logger</span>.<span class="ruby-identifier">debug</span>(<span class="ruby-node">&quot;Finishing say_hello with #{to}&quot;</span>)
    <span class="ruby-identifier">result</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment">#---</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">ChildClass</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ParentClass</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">say_hello</span>(<span class="ruby-identifier">to</span>)
    <span class="ruby-keyword">super</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">op</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> :<span class="ruby-identifier">validate</span>
        <span class="ruby-operator">!</span><span class="ruby-identifier">to</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># This code only gets executed if &lt;to&gt; is not nil</span>
        <span class="ruby-comment"># And we don&#39;t have to worry about logging</span>
        <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;hello #{to}!&quot;</span>
        <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment">#---</span>

<span class="ruby-identifier">obj</span> = <span class="ruby-constant">ChildClass</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">say_hello</span>(<span class="ruby-string">&#39;world&#39;</span>)
<span class="ruby-comment"># hello world!</span>
</pre>

<p>As you can see we executed the child method statements multiple times from
the parent method so that we could abstract out some of the operations in
the sub class, thus making the provider easier to develop and the parent
abstract enough to support various providers.</p>

<p>Also notice that we did not expose the external block execution to the
users of the class or to child classes of ChildClass.  In this case we
chose to stop the block execution propogation because the implementation
was very simple; say hello.  If it had been more complex we could propogate
the block execution on down the line.</p>

<h4 id="label-Event+based+plugin+extensions">Event based plugin extensions</h4>

<p>It is extremely useful to be able to tap into the execution flow of
existing  objects and methods.  This allows the flow to change based on
actions that are  defined by plugins that hook into other plugins
operations.</p>

<p><a href="Nucleon.html">Nucleon</a> implements a plugin type called the
Extension.  It&#39;s sole purpose is to extend other plugins (including
Extensions).  The base extension plugin has no  special methods, leaving
the method interface pretty clean.  These extensions are instantiated (only
one per defined extension) and they act on events as the application
execution flows.  The are true class instances so they can manage state
between registered events.</p>

<p>Events are triggered by named method calls run by a central plugin manager.
They look just like regular methods but call out to other extensions to
help configure, get/set values, or otherwise act on the state of the
application at the time triggered.  Extensions register for events by
defining an instance  method that matches the name of the event.  Every
event method (hook) takes one parameter (you guessed it); a configuration. 
This makes the process quick and painless and code for events remains
easily localized and separated.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-comment">#</span>
<span class="ruby-comment"># This would be defined within a namespaced load path.</span>
<span class="ruby-comment"># More on that in the usage section.</span>
<span class="ruby-comment"># </span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">MyExtension</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Nucleon</span>.<span class="ruby-identifier">plugin_class</span>(:<span class="ruby-identifier">extension</span>)

  <span class="ruby-ivar">@objs</span> = []

  <span class="ruby-comment">#---</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">myobj_config</span>(<span class="ruby-identifier">config</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-constant">Nucleon</span>.<span class="ruby-identifier">check</span>(:<span class="ruby-identifier">is_nucleon_awesome</span>, <span class="ruby-identifier">config</span>)
      <span class="ruby-comment"># I&#39;m going to be nice and let other extensions help me decide.</span>
      <span class="ruby-identifier">config</span>[:<span class="ruby-identifier">awesome</span>] = <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">is_nucleon_awesome</span>(<span class="ruby-identifier">config</span>)
    <span class="ruby-keyword">true</span> <span class="ruby-comment"># Of course I&#39;m a little biased</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">record_object</span>(<span class="ruby-identifier">config</span>)
    <span class="ruby-ivar">@objs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">config</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment">#---</span>

<span class="ruby-comment"># Extension would normally be loaded via Nucleon.register(load_path)</span>
<span class="ruby-comment"># No one overruled me, Whew!</span>

<span class="ruby-identifier">myobj</span> = <span class="ruby-constant">Nucleon</span>.<span class="ruby-identifier">config</span>(:<span class="ruby-identifier">myobj</span>, { :<span class="ruby-identifier">nucleon</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">is</span> })
<span class="ruby-comment"># myobj = {</span>
<span class="ruby-comment">#   :nucleon =&gt; :is,</span>
<span class="ruby-comment">#   :awesome =&gt; true</span>
<span class="ruby-comment"># }</span>

<span class="ruby-constant">Nucleon</span>.<span class="ruby-identifier">exec</span>(:<span class="ruby-identifier">record_object</span>, <span class="ruby-identifier">myobj</span>)
</pre>

<h4 id="label-Middleware+sequences+%28NOT+YET+IMPLEMENTED%29">Middleware sequences (NOT YET IMPLEMENTED)</h4>

<p>We are evaluating the implementation of stacked actions or some form of 
composite plugin execution model.  Mitchell Hashimoto has created an
extremely useful solution for Vagrant and a separate middleware gem that
provides  standalone middleware sequencing capabilities.</p>

<p>In the future we might integrate this system to stack our action plugins so
we can derive action lists.  This would most likely be a framework that was
primarily used by the action plugin system and derivative projects.</p>

<p>Your thoughts are welcome?  Contact the maintainers or file an issue.</p>

<h4 id="label-Execution+plans+%28NOT+YET+MIGRATED%29">Execution plans (NOT YET MIGRATED)</h4>

<p>In the early days of this project (or it&#39;s predecessor), I created and
utilized  a system of executing JSON based CLI execution plans that could
respond to and  trigger events, resulting in a responsive CLI sequence that
was programmed entirely in JSON as configurations.  This fits our “make
everything a  configuration” philosophy.</p>

<p>This system will be brought up to the current architecture before version
1.0 (first production release).  It will be very powerful, allowing for the
creation of new CLI commands and event driven programmatic actions purely
by working with JSON, YAML, or any other defined translator in the
application.</p>

<p>The goal is to allow for the ultimate in high level scriptable programming;
configuring data objects that execute programs.</p>

<p>This might eventually be integrated with the middleware sequences discussed
above.</p>

<h3 id="label-Easily+parallel">Easily parallel</h3>

<p>Concurrency is the backbone of scalability and fault tolerance.  With <a
href="Nucleon.html">Nucleon</a> we seek to create a system that can utilize
the whole of the resources available to us in the most flexible way
possible.  We should be able to write parallel capable objects without even
thinking about it (ok, maybe a litle).  It should also be capable of
completely disabling the parallel execution and library inclusion to make
it easier to troubleshoot and debug.</p>

<p>There are two main popular concurrency methodologies currently being
promoted today.  Erlang has popularized the actor based concurrency model
which has been  widely discussed and adopted across the enterprise. 
Another popular model is  channel based communication between workers
popularized by the Go programming  language.  We would eventually like to
support both.</p>

<p>Currently we utilize and build on a super awesome Actor based parallel
framework for Ruby called Celluloid (<a
href="http://celluloid.io">celluloid.io</a>).  This library is designed 
around principles gleaned from Erlang&#39;s concurrency mechanism and is
built  around an object oriented message passing architecture.  It is very
well  written.</p>

<p><a href="Nucleon.html">Nucleon</a> provides an interface to wrap and load
Celluloid actor proxies into your object&#39;s but allows for the parallel
abilities to be completely disabled,  reducing the complexity of the code
(good for stack traces) and allowing for  sequentially based debugging
tools (trapping through the code) to function  correctly.</p>

<p>How easy is it to create a parallel object?</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyClass</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Nucleon</span><span class="ruby-operator">::</span><span class="ruby-constant">Parallel</span> <span class="ruby-comment"># Uses Celluloid under the hood!</span>

  <span class="ruby-ivar">@order</span> = []

  <span class="ruby-identifier">attr_reader</span> :<span class="ruby-identifier">order</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">print_number</span>(<span class="ruby-identifier">num</span>)
    <span class="ruby-identifier">sleep</span>(<span class="ruby-constant">Random</span>.<span class="ruby-identifier">rand</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>))
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Printing: #{num}&quot;</span>
    <span class="ruby-ivar">@order</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">num</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment">#---</span>

<span class="ruby-identifier">printer</span> = <span class="ruby-constant">MyClass</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">printer</span>.<span class="ruby-identifier">parallel</span>(:<span class="ruby-identifier">print_number</span>, <span class="ruby-constant">Array</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>))
<span class="ruby-comment"># prints sequence out of sequence</span>
<span class="ruby-comment"># unless (ENV[&#39;NUCLEON_DEBUG&#39;] or ENV[&#39;NUCLEON_NO_PARALLEL&#39;] defined)</span>

<span class="ruby-identifier">printer</span>.<span class="ruby-identifier">order</span> <span class="ruby-comment"># Whatever order they were executed in</span>
</pre>

<p>In the future we will put research into the channel based communication 
concurrency model used by Go.</p>

<h3 id="label-Automatable+project+workflows">Automatable project workflows</h3>

<p>Configurations are great, but if they can&#39;t persist and be recalled
later by the application or framework they have limited effectiveness. 
Since we want projects that are distributed in nature the configurations
need to be, not just persistent, but remotely available.  With this in mind
the Project plugin was born.</p>

<p>The project is a revisionable data store with a local directory.  It could
be  a file repository or an active database some where (or even a service
like  Dropbox).  The idea is we provide a basic implementation of the
project in  abstract operations and specialized providers fill in the
details.</p>

<p>So far we have implemented Git, and an extension to Git, GitHub.  We use a
lot  of text based files in our projects and Git is great for compressing
and storing versions of them, so Git was the first project integration. 
Git is also a  highly popular distributed mission critical capable version
control system,  which is also a contributing factor in its prioritization.</p>

<p>In the future we plan on integrating more project providers and reworking
the Git provider to utilize more of the performance oriented Rugged
(LibGit2) libraries.</p>

<p>What a project looks like as a programming construct:</p>

<pre class="ruby"><span class="ruby-identifier">project</span> = <span class="ruby-constant">Nucleon</span>.<span class="ruby-identifier">project</span>({ 
  :<span class="ruby-identifier">provider</span>  =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">github</span>, <span class="ruby-comment"># Project resides at Github (use special API sauce)</span>
  :<span class="ruby-identifier">reference</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;coralnexus/nucleon&#39;</span>, <span class="ruby-comment"># GitHub identifier</span>
  :<span class="ruby-identifier">revision</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;0.1&#39;</span>, <span class="ruby-comment"># Revision to ensure checked out for project</span>
  :<span class="ruby-identifier">directory</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;/tmp/nucleon&#39;</span>, <span class="ruby-comment"># Directory to setup project</span>
  :<span class="ruby-identifier">create</span>    =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-comment"># Create project if does not exist yet</span>
  :<span class="ruby-identifier">pull</span>      =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span> <span class="ruby-comment"># Go ahead and pull updates</span>
})

<span class="ruby-comment"># If you have a .netrc file with auth credentials in your home directory</span>
<span class="ruby-comment"># the plugin will manage deploy keys for private projects.</span>

<span class="ruby-identifier">origin</span> = <span class="ruby-identifier">project</span>.<span class="ruby-identifier">remote</span>(:<span class="ruby-identifier">origin</span>)
<span class="ruby-comment"># http://github.com/coralnexus/nucleon.git</span>

<span class="ruby-identifier">edit</span> = <span class="ruby-identifier">project</span>.<span class="ruby-identifier">remote</span>(:<span class="ruby-identifier">edit</span>)
<span class="ruby-comment"># git@github.com:coralnexus/nucleon.git</span>

<span class="ruby-identifier">project</span>.<span class="ruby-identifier">checkout</span>(<span class="ruby-string">&#39;0.1&#39;</span>)
<span class="ruby-identifier">project</span>.<span class="ruby-identifier">pull</span>(:<span class="ruby-identifier">edit</span>)

<span class="ruby-identifier">project</span>.<span class="ruby-identifier">ignore</span>(<span class="ruby-string">&#39;my-tmp-file.txt&#39;</span>)

<span class="ruby-identifier">project</span>.<span class="ruby-identifier">commit</span>(<span class="ruby-string">&#39;some-file.txt, { :message =&gt; &#39;</span><span class="ruby-constant">Changing</span> <span class="ruby-identifier">some</span> <span class="ruby-identifier">file</span> <span class="ruby-identifier">text</span>.<span class="ruby-string">&#39; })

project.add_subproject(&#39;</span><span class="ruby-identifier">other</span><span class="ruby-operator">/</span><span class="ruby-identifier">nucleon</span><span class="ruby-string">&#39;, &#39;</span><span class="ruby-identifier">http</span><span class="ruby-operator">:</span><span class="ruby-regexp">//</span><span class="ruby-identifier">github</span>.<span class="ruby-identifier">com</span><span class="ruby-operator">/</span><span class="ruby-identifier">coralnexus</span><span class="ruby-operator">/</span><span class="ruby-identifier">nucleon</span>.<span class="ruby-identifier">git</span>, <span class="ruby-string">&#39;0.1&#39;</span>)
<span class="ruby-identifier">project</span>.<span class="ruby-identifier">delete_subproject</span>(<span class="ruby-string">&#39;other/nucleon&#39;</span>)
</pre>

<p>There are more methods and options for the above methods, but the above
should give you an idea of what you can expect.  The interface API is
definitely skewed towards the Git idioms, such as remotes, checkout,
commit, but the  implementation can vary so if the data store can map to
most of the typical distributed version control ablities then it should be
fairly easy to integrate.</p>

<h3 id="label-Flexible+action+execution+model">Flexible action execution model</h3>

<p>One of the goals of the project is to create a very flexible action
execution system that can be used from the CLI, internally as method calls,
and  eventually as service API endpoints.</p>

</div>



<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.2.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

